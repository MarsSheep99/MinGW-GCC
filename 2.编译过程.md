## 2.编译过程

#### 一、gcc main.c -o main：

gcc编译器程序读取源文件main.c，并把它翻译成一个可执行目标文件main。翻译过程分为四个阶段：**预处理（Preprocessing）**、**编译（Compilation）**、 **汇编（Assembly）**、 **链接（Linking）**。这四个阶段分别由预处理器、编译器、汇编器、链接器完成，执行这四个阶段的程序共同构成**编译系统**。

#### 二、预处理阶段：

1.处理#include预编译指令，将被包含的文件直接插入到预编译指令的位置。

2.处理所有条件预编译指令，如#if、#ifdef、#elif、#else、#endif等。

3.预处理器将所有的#define删除，并且展开所有的宏定义。

4.删除所有的注释。

5.添加行号和文件标识，以便编译时产生调试用的行号及编译错误警告行号。

6.保留所有的#pragma编译器指令，因为编译器需要使用它们。

#### 三、编译：

编译器将预处理完的文本文件main.i进行一系列词法分析、语法分析、语义分析和优化，翻译成文本文件main.s。

#### 四、汇编：

汇编器将main.s翻译成机器语言指令，把这些指令打包成一种叫做可重定位目标程序的格式，并将结果保存在目标文件main.o中，main.o是一个二进制文件。

#### 五、链接：

main程序调用了printf函数，它存在于一个单独编译好了的目标文件中，而这个文件必须以某种方式合并到我们的main.o程序中，链接器负责处理这种合并，结果就得到了main文件，它是一个可执行目标文件（即可执行文件），可以被加载到内存中，由系统执行。（链接程序运行需要的一大堆目标文件，以及所依赖的其他库文件，最后生成可执行文件。

1.静态链接

在生成可执行文件的时候（链接），把所需要的函数的二进制代码都包含到可执行文件中去，在程序发布的时候就不需要依赖库，也就是不再需要带着库一块发布，程序可以独立执行，浪费内存空间，在多线程的操作系统下，同一时间，内存中可能存在多个相同的公共库函数，程序的开发与发布流程受模块制约，只要有一个模块更新就要重新编译打包整个代码。

2.动态链接

在编译的时候不直接拷贝可执行代码，而是通过记录一系列符号和参数，在程序运行或加载时将这些信息传递给操作系统，操作系统负责将需要的动态库加载到内存中，然后程序在运行到指定的代码时，去共享执行内存中已经加载的动态库可执行代码，最终达到运行时链接的目的，解决了静态链接的缺陷，更适应现代的大型软件开发，由于是运行时加载，可能会影响程序的前期执行性能。

#### 总结：

```
gcc(g++) <options> <sourcefile>
	options
		-E -o <filename.i> 编译过程进行到预处理
		-S 编译过程进行到编译
		-c 编译过程进行到汇编
		-static 指定静态链接
```

